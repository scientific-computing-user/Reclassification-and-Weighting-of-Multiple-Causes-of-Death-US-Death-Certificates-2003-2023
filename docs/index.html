<!doctype html>
<html lang="en">
<head>
  <meta charset="utf-8">
  <meta name="viewport" content="width=device-width, initial-scale=1">
  <title>Death-Certificate Atlas | Interactive Paper Companion</title>
  <link rel="preconnect" href="https://fonts.googleapis.com">
  <link rel="preconnect" href="https://fonts.gstatic.com" crossorigin>
  <link href="https://fonts.googleapis.com/css2?family=Outfit:wght@300;400;500;700;800&family=Fraunces:opsz,wght@9..144,500;9..144,700&display=swap" rel="stylesheet">
  <script src="https://cdn.plot.ly/plotly-2.35.2.min.js"></script>
  <style>
    :root {
      --bg-0: #06121d;
      --bg-1: #091f33;
      --bg-2: #102b46;
      --surface: rgba(8, 23, 37, 0.72);
      --surface-strong: rgba(9, 29, 48, 0.88);
      --line: rgba(167, 216, 255, 0.22);
      --ink: #f4fbff;
      --muted: #a7c1d8;
      --accent-a: #1ad8c8;
      --accent-b: #ff7a45;
      --accent-c: #ffe16a;
      --accent-d: #7fd1ff;
      --good: #30e296;
      --bad: #ff6f6f;
      --glow: 0 0 0 1px rgba(103, 190, 255, 0.18), 0 24px 45px rgba(1, 12, 21, 0.5);
    }

    * { box-sizing: border-box; }

    body {
      margin: 0;
      color: var(--ink);
      background: radial-gradient(circle at 8% 8%, #11476b 0%, transparent 33%), radial-gradient(circle at 90% 16%, #7b2f2a 0%, transparent 32%), radial-gradient(circle at 70% 90%, #0f6a5b 0%, transparent 28%), linear-gradient(160deg, var(--bg-0), var(--bg-1) 54%, var(--bg-2));
      font-family: "Outfit", system-ui, sans-serif;
      min-height: 100vh;
      overflow-x: hidden;
    }

    .aurora {
      position: fixed;
      inset: -20%;
      pointer-events: none;
      z-index: -1;
      background:
        radial-gradient(circle at 18% 22%, rgba(16, 207, 183, 0.24), transparent 30%),
        radial-gradient(circle at 75% 18%, rgba(255, 139, 70, 0.21), transparent 30%),
        radial-gradient(circle at 46% 80%, rgba(127, 209, 255, 0.17), transparent 36%);
      filter: blur(20px);
      animation: drift 15s ease-in-out infinite alternate;
      transform-origin: center;
    }

    @keyframes drift {
      0% { transform: scale(1) translate3d(0, 0, 0); }
      100% { transform: scale(1.08) translate3d(2.5%, -2.2%, 0); }
    }

    .shell {
      width: min(1240px, 95vw);
      margin: 0 auto;
      padding: 1.3rem 0 3.2rem;
    }

    .hero {
      position: relative;
      border: 1px solid var(--line);
      border-radius: 28px;
      background: linear-gradient(136deg, rgba(8, 28, 46, 0.95), rgba(7, 31, 49, 0.84) 44%, rgba(40, 31, 20, 0.84));
      box-shadow: var(--glow);
      overflow: hidden;
      padding: 2.1rem 1.9rem 1.35rem;
      isolation: isolate;
    }

    .hero::after {
      content: "";
      position: absolute;
      inset: -20% -15% auto auto;
      width: 340px;
      height: 340px;
      background: radial-gradient(circle at center, rgba(255, 170, 79, 0.45), transparent 62%);
      filter: blur(4px);
      transform: translate(20%, -20%);
      z-index: -1;
    }

    h1, h2, h3 {
      margin: 0;
      line-height: 1.2;
      letter-spacing: 0.01em;
    }

    h1 {
      font-family: "Fraunces", serif;
      font-size: clamp(1.85rem, 3.8vw, 3.2rem);
      margin-bottom: 0.45rem;
    }

    h2 {
      font-family: "Fraunces", serif;
      font-size: clamp(1.22rem, 2.2vw, 1.75rem);
      margin-bottom: 0.62rem;
    }

    h3 {
      font-size: 1rem;
      margin-bottom: 0.4rem;
      color: var(--accent-d);
      text-transform: uppercase;
      letter-spacing: 0.09em;
      font-weight: 700;
    }

    .subtitle {
      margin: 0;
      max-width: 89ch;
      color: #d5e9fb;
      font-size: 1.03rem;
    }

    .kpi-grid {
      margin-top: 1.05rem;
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(160px, 1fr));
      gap: 0.62rem;
    }

    .kpi {
      padding: 0.72rem 0.8rem;
      border-radius: 14px;
      background: rgba(9, 33, 53, 0.72);
      border: 1px solid rgba(153, 208, 255, 0.23);
      transition: transform .18s ease, box-shadow .22s ease;
    }

    .kpi:hover {
      transform: translateY(-2px) scale(1.01);
      box-shadow: 0 12px 22px rgba(1, 19, 34, 0.42);
    }

    .kpi-k {
      text-transform: uppercase;
      letter-spacing: 0.08em;
      font-size: 0.72rem;
      color: #9fc8e8;
      font-weight: 700;
      margin-bottom: 0.18rem;
    }

    .kpi-v {
      font-size: 1.31rem;
      font-weight: 700;
      color: #f5fdff;
    }

    .meta {
      margin-top: 0.8rem;
      color: #afcae3;
      font-size: 0.88rem;
    }

    .quick-links {
      margin-top: 0.86rem;
      display: flex;
      flex-wrap: wrap;
      gap: 0.75rem;
      font-weight: 700;
    }

    a {
      color: #8be8ff;
      text-decoration: none;
    }

    a:hover { text-decoration: underline; }

    .section {
      margin-top: 1rem;
      border: 1px solid var(--line);
      border-radius: 22px;
      padding: 1rem;
      background: var(--surface);
      box-shadow: var(--glow);
      backdrop-filter: blur(5px);
    }

    .section-head {
      display: flex;
      flex-wrap: wrap;
      justify-content: space-between;
      gap: 0.5rem;
      align-items: flex-end;
      margin-bottom: 0.58rem;
    }

    .section-note {
      color: var(--muted);
      font-size: 0.93rem;
      margin: 0;
      max-width: 78ch;
    }

    .controls {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(180px, 1fr));
      gap: 0.58rem;
      margin: 0.65rem 0;
    }

    .control {
      display: flex;
      flex-direction: column;
      gap: 0.28rem;
    }

    label {
      font-size: 0.78rem;
      text-transform: uppercase;
      letter-spacing: 0.08em;
      color: #9ec4df;
      font-weight: 700;
    }

    select,
    input[type="search"],
    input[type="range"],
    button {
      border: 1px solid rgba(156, 211, 251, 0.3);
      border-radius: 11px;
      background: rgba(13, 39, 60, 0.92);
      color: #f1fbff;
      padding: 0.5rem 0.58rem;
      font-family: inherit;
      font-size: 0.95rem;
    }

    button {
      cursor: pointer;
      font-weight: 700;
      background: linear-gradient(130deg, rgba(21, 173, 161, 0.9), rgba(4, 125, 156, 0.9));
      border-color: rgba(144, 232, 255, 0.45);
    }

    button:hover {
      filter: brightness(1.07);
    }

    .pills {
      display: flex;
      flex-wrap: wrap;
      gap: 0.4rem;
      margin-bottom: 0.66rem;
      max-height: 138px;
      overflow: auto;
      padding-right: 0.22rem;
    }

    .pill {
      border: 1px solid rgba(140, 201, 245, 0.4);
      border-radius: 999px;
      background: rgba(13, 38, 60, 0.84);
      padding: 0.24rem 0.6rem;
      font-size: 0.82rem;
      color: #def4ff;
      display: flex;
      align-items: center;
      gap: 0.34rem;
      transition: transform .16s ease;
    }

    .pill:hover { transform: translateY(-1px); }

    .pill input { margin: 0; }

    .plot {
      width: 100%;
      min-height: 360px;
      border-radius: 14px;
      border: 1px solid rgba(150, 214, 255, 0.16);
      overflow: hidden;
      background: rgba(4, 18, 29, 0.45);
    }

    .plot.short { min-height: 320px; }

    .grid-2 {
      display: grid;
      grid-template-columns: repeat(auto-fit, minmax(340px, 1fr));
      gap: 0.9rem;
    }

    .timeline-row {
      display: grid;
      grid-template-columns: 1fr auto;
      gap: 0.5rem;
      align-items: end;
    }

    .year-badge {
      font-size: 0.93rem;
      color: #bde4ff;
      font-weight: 700;
    }

    .status-strip {
      margin-top: 0.55rem;
      font-size: 0.9rem;
      color: #b7d7ed;
      display: flex;
      gap: 0.9rem;
      flex-wrap: wrap;
    }

    .claim-wrap,
    .table-wrap {
      overflow: auto;
      max-height: 380px;
      border: 1px solid rgba(160, 214, 250, 0.2);
      border-radius: 12px;
      background: rgba(5, 22, 36, 0.62);
    }

    table {
      border-collapse: collapse;
      width: 100%;
      font-size: 0.9rem;
    }

    thead {
      position: sticky;
      top: 0;
      z-index: 1;
      background: rgba(10, 36, 57, 0.95);
    }

    th,
    td {
      border: 1px solid rgba(141, 194, 231, 0.18);
      padding: 0.39rem 0.45rem;
      text-align: right;
      white-space: nowrap;
    }

    th:first-child,
    td:first-child {
      text-align: left;
      max-width: 420px;
      overflow: hidden;
      text-overflow: ellipsis;
    }

    .badge {
      display: inline-block;
      padding: 0.14rem 0.52rem;
      border-radius: 999px;
      font-size: 0.74rem;
      font-weight: 700;
    }

    .ok { background: rgba(48, 226, 150, 0.16); color: var(--good); }
    .no { background: rgba(255, 111, 111, 0.16); color: var(--bad); }

    .loading {
      margin-top: 1.4rem;
      text-align: center;
      font-size: 1rem;
      color: #ccedf7;
    }

    .spinner {
      width: 24px;
      height: 24px;
      border-radius: 50%;
      border: 2px solid rgba(255, 255, 255, 0.28);
      border-top-color: #66f1ff;
      margin: 0 auto 0.4rem;
      animation: spin .9s linear infinite;
    }

    @keyframes spin { to { transform: rotate(360deg); } }

    .hidden { display: none; }

    @media (max-width: 720px) {
      .shell { width: min(1240px, 97vw); }
      .hero,
      .section { padding: 0.82rem; border-radius: 16px; }
      .plot { min-height: 300px; }
      .plot.short { min-height: 280px; }
      th,
      td { font-size: 0.82rem; }
    }
  </style>
</head>
<body>
  <div class="aurora"></div>
  <div class="shell">
    <header class="hero">
      <h1>Death-Certificate Atlas</h1>
      <p class="subtitle">
        An interactive companion to the paper on reclassification and weighting of multiple causes of death in U.S. certificates (2003â€“2023).
        Explore category shifts, temporal dynamics, and transition pathways with live visualizations driven by repository data.
      </p>
      <div id="hero-kpis" class="kpi-grid"></div>
      <div id="hero-meta" class="meta"></div>
      <div class="quick-links">
        <a href="https://github.com/scientific-computing-user/Reclassification-and-Weighting-of-Multiple-Causes-of-Death-US-Death-Certificates-2003-2023" target="_blank" rel="noopener">Repository</a>
        <a href="https://github.com/scientific-computing-user/Reclassification-and-Weighting-of-Multiple-Causes-of-Death-US-Death-Certificates-2003-2023/blob/main/results/validation/claim_check.md" target="_blank" rel="noopener">Claim Report</a>
        <a href="https://github.com/scientific-computing-user/Reclassification-and-Weighting-of-Multiple-Causes-of-Death-US-Death-Certificates-2003-2023/blob/main/paper/2026.01.31.26345264v1.full.pdf" target="_blank" rel="noopener">Paper PDF</a>
      </div>
    </header>

    <div id="loading" class="loading">
      <div class="spinner"></div>
      Loading visual atlas data...
    </div>

    <main id="app" class="hidden">
      <section class="section">
        <div class="section-head">
          <div>
            <h2>Burden Landscape Through Time</h2>
            <p class="section-note">Stacked area trajectories across categories. Toggle categories to inspect contribution shifts.</p>
          </div>
        </div>
        <div class="controls">
          <div class="control">
            <label for="trend-scheme">Weighting Scheme</label>
            <select id="trend-scheme"></select>
          </div>
          <div class="control">
            <label for="trend-bucket">Population Bucket</label>
            <select id="trend-bucket"></select>
          </div>
        </div>
        <div id="category-pills" class="pills"></div>
        <div id="trend-plot" class="plot"></div>
      </section>

      <section class="section">
        <div class="section-head">
          <div>
            <h2>Constellation of Causes</h2>
            <p class="section-note">Each bubble is a broad category for one year: x = reclassification change (%), y = share of deaths, size = absolute burden.</p>
          </div>
          <div class="year-badge" id="year-badge"></div>
        </div>

        <div class="controls">
          <div class="control">
            <label for="bubble-scheme">Weighting Scheme</label>
            <select id="bubble-scheme"></select>
          </div>
          <div class="control">
            <label for="bubble-bucket">Population Bucket</label>
            <select id="bubble-bucket"></select>
          </div>
          <div class="control">
            <label for="bubble-year">Year</label>
            <input id="bubble-year" type="range" min="2003" max="2023" step="1" value="2020">
          </div>
          <div class="control">
            <label>&nbsp;</label>
            <button id="play-years" type="button">Play Timeline</button>
          </div>
        </div>

        <div id="bubble-plot" class="plot short"></div>
      </section>

      <div class="grid-2">
        <section class="section">
          <div class="section-head">
            <div>
              <h2>Seasonality Heatmap</h2>
              <p class="section-note">Monthly intensity by year for one category.</p>
            </div>
          </div>
          <div class="controls">
            <div class="control">
              <label for="heat-scheme">Weighting Scheme</label>
              <select id="heat-scheme"></select>
            </div>
            <div class="control">
              <label for="heat-bucket">Population Bucket</label>
              <select id="heat-bucket"></select>
            </div>
            <div class="control">
              <label for="heat-letter">Category</label>
              <select id="heat-letter"></select>
            </div>
          </div>
          <div id="heat-plot" class="plot short"></div>
        </section>

        <section class="section">
          <div class="section-head">
            <div>
              <h2>Flow Theater</h2>
              <p class="section-note">Entity-to-Record transition pathways. Hover to inspect dominant routes.</p>
            </div>
          </div>
          <div class="controls">
            <div class="control">
              <label for="flow-min">Min Flow Count</label>
              <input id="flow-min" type="range" min="10000" max="300000" step="5000" value="60000">
            </div>
            <div class="control">
              <label for="flow-max">Max Edges</label>
              <input id="flow-max" type="range" min="8" max="40" step="1" value="22">
            </div>
          </div>
          <div class="status-strip">
            <span id="flow-min-label"></span>
            <span id="flow-max-label"></span>
          </div>
          <div id="flow-plot" class="plot short"></div>
        </section>
      </div>

      <div class="grid-2">
        <section class="section">
          <div class="section-head">
            <div>
              <h2>Relative Reclassification Impact</h2>
              <p class="section-note">Percent change from Entity to Record axis by category.</p>
            </div>
          </div>
          <div id="impact-plot" class="plot short"></div>
        </section>

        <section class="section">
          <div class="section-head">
            <div>
              <h2>Claim Validation Explorer</h2>
              <p class="section-note">Search and filter claim checks from the audit report.</p>
            </div>
          </div>
          <div class="controls">
            <div class="control">
              <label for="claim-status">Status</label>
              <select id="claim-status">
                <option value="all">All</option>
                <option value="pass">PASS</option>
                <option value="fail">FAIL</option>
              </select>
            </div>
            <div class="control">
              <label for="claim-search">Search</label>
              <input id="claim-search" type="search" placeholder="Type claim text">
            </div>
          </div>
          <div class="claim-wrap">
            <table>
              <thead>
                <tr>
                  <th>Claim</th>
                  <th>Expected</th>
                  <th>Observed</th>
                  <th>Diff</th>
                  <th>Tol</th>
                  <th>Status</th>
                </tr>
              </thead>
              <tbody id="claim-body"></tbody>
            </table>
          </div>
        </section>
      </div>

      <section class="section">
        <div class="section-head">
          <div>
            <h2>Top Transition Table</h2>
            <p class="section-note">Largest transition counts currently visible under flow filters.</p>
          </div>
        </div>
        <div class="table-wrap">
          <table>
            <thead>
              <tr>
                <th>From (Entity)</th>
                <th>To (Record)</th>
                <th>Count</th>
              </tr>
            </thead>
            <tbody id="flow-table"></tbody>
          </table>
        </div>
      </section>
    </main>
  </div>

  <script>
    const CATEGORY_ORDER = ["V", "F", "T", "S", "H", "E", "C", "B", "D", "A", "P", "X", "N", "R", "U"];
    const CATEGORY_COLOR = {
      V: "#00e5ff",
      F: "#00bfa5",
      T: "#ff9f1c",
      S: "#ff4d6d",
      H: "#ff7b00",
      E: "#8bc34a",
      C: "#f06292",
      B: "#5fa8ff",
      D: "#c792ea",
      A: "#ffcc80",
      P: "#f48fb1",
      X: "#ffd166",
      N: "#80cbc4",
      R: "#9fa8da",
      U: "#b0bec5",
    };

    const state = {
      data: null,
      trendScheme: "1",
      trendBucket: "ALL",
      selectedLetters: new Set(["V", "T", "F", "S", "X", "N", "R"]),
      bubbleScheme: "1",
      bubbleBucket: "ALL",
      bubbleYear: 2020,
      heatScheme: "1",
      heatBucket: "ALL",
      heatLetter: "V",
      claimStatus: "all",
      claimSearch: "",
      flowMin: 60000,
      flowMax: 22,
      timer: null,
    };

    const el = {
      loading: document.getElementById("loading"),
      app: document.getElementById("app"),
      heroKpis: document.getElementById("hero-kpis"),
      heroMeta: document.getElementById("hero-meta"),
      trendScheme: document.getElementById("trend-scheme"),
      trendBucket: document.getElementById("trend-bucket"),
      categoryPills: document.getElementById("category-pills"),
      bubbleScheme: document.getElementById("bubble-scheme"),
      bubbleBucket: document.getElementById("bubble-bucket"),
      bubbleYear: document.getElementById("bubble-year"),
      yearBadge: document.getElementById("year-badge"),
      playYears: document.getElementById("play-years"),
      heatScheme: document.getElementById("heat-scheme"),
      heatBucket: document.getElementById("heat-bucket"),
      heatLetter: document.getElementById("heat-letter"),
      flowMin: document.getElementById("flow-min"),
      flowMax: document.getElementById("flow-max"),
      flowMinLabel: document.getElementById("flow-min-label"),
      flowMaxLabel: document.getElementById("flow-max-label"),
      claimStatus: document.getElementById("claim-status"),
      claimSearch: document.getElementById("claim-search"),
      claimBody: document.getElementById("claim-body"),
      flowTable: document.getElementById("flow-table"),
    };

    function categoryName(letter) {
      const names = state.data.labels.letter_name;
      return names[letter] ? `${names[letter]} (${letter})` : letter;
    }

    function schemeName(scheme) {
      return state.data.labels.scheme_name[scheme] || scheme;
    }

    function fmtInt(value) {
      return Number(value).toLocaleString("en-US", { maximumFractionDigits: 0 });
    }

    function fmtNum(value, decimals = 3) {
      return Number(value).toLocaleString("en-US", {
        minimumFractionDigits: decimals,
        maximumFractionDigits: decimals,
      });
    }

    function sortedUnique(values) {
      return Array.from(new Set(values)).sort((a, b) => a.localeCompare(b));
    }

    function byCategoryOrder(a, b) {
      return CATEGORY_ORDER.indexOf(a) - CATEGORY_ORDER.indexOf(b);
    }

    function fillSelect(selectEl, values, formatter) {
      selectEl.innerHTML = values
        .map((value) => `<option value="${value}">${formatter ? formatter(value) : value}</option>`)
        .join("");
    }

    function buildHero() {
      const summary = state.data.claim_metrics.summary;
      const checks = state.data.claim_metrics.checks;
      const passCount = checks.filter((item) => item.pass).length;

      const kpis = [
        ["Deaths analyzed", fmtInt(summary.total_deaths)],
        ["Claim checks", `${passCount}/${checks.length}`],
        ["Category concordance", `${fmtNum(summary.concordance_category_pct, 2)}%`],
        ["ICD concordance", `${fmtNum(summary.concordance_icd_pct, 2)}%`],
        ["COVID promotions", fmtInt(summary.covid_promotions)],
        ["COVID demotions", fmtInt(summary.covid_demotions)],
      ];

      el.heroKpis.innerHTML = kpis
        .map(
          ([k, v]) =>
            `<article class="kpi"><div class="kpi-k">${k}</div><div class="kpi-v">${v}</div></article>`
        )
        .join("");

      const generated = new Date(state.data.meta.generated_utc);
      el.heroMeta.textContent = `Generated from repository outputs on ${generated.toLocaleString()} | fallback ${summary.external_prefix_fallback || "none"} applied for unmapped external prefixes.`;
    }

    function setupControls() {
      const yearly = state.data.series.yearly;
      const monthly = state.data.series.monthly;
      const schemes = sortedUnique(yearly.map((row) => row.scheme));
      const trendBuckets = sortedUnique(yearly.map((row) => row.bucket));
      const heatBuckets = sortedUnique(monthly.map((row) => row.bucket));
      const letters = CATEGORY_ORDER.filter((letter) => state.data.labels.letter_name[letter]);

      fillSelect(el.trendScheme, schemes, schemeName);
      fillSelect(el.trendBucket, trendBuckets, (value) => value);
      fillSelect(el.bubbleScheme, schemes, schemeName);
      fillSelect(el.bubbleBucket, trendBuckets, (value) => value);
      fillSelect(el.heatScheme, schemes, schemeName);
      fillSelect(el.heatBucket, heatBuckets, (value) => value);
      fillSelect(el.heatLetter, letters, categoryName);

      el.trendScheme.value = state.trendScheme;
      el.trendBucket.value = state.trendBucket;
      el.bubbleScheme.value = state.bubbleScheme;
      el.bubbleBucket.value = state.bubbleBucket;
      el.bubbleYear.value = String(state.bubbleYear);
      el.heatScheme.value = state.heatScheme;
      el.heatBucket.value = state.heatBucket;
      el.heatLetter.value = state.heatLetter;

      el.categoryPills.innerHTML = letters
        .map((letter) => {
          const checked = state.selectedLetters.has(letter) ? "checked" : "";
          return `<label class="pill"><input type="checkbox" data-letter="${letter}" ${checked}>${categoryName(letter)}</label>`;
        })
        .join("");

      el.categoryPills.querySelectorAll("input[type=checkbox]").forEach((input) => {
        input.addEventListener("change", (event) => {
          const letter = event.target.dataset.letter;
          if (event.target.checked) {
            state.selectedLetters.add(letter);
          } else {
            state.selectedLetters.delete(letter);
          }
          renderTrend();
        });
      });

      el.trendScheme.addEventListener("change", (event) => {
        state.trendScheme = event.target.value;
        renderTrend();
      });
      el.trendBucket.addEventListener("change", (event) => {
        state.trendBucket = event.target.value;
        renderTrend();
      });

      el.bubbleScheme.addEventListener("change", (event) => {
        state.bubbleScheme = event.target.value;
        renderBubble();
      });
      el.bubbleBucket.addEventListener("change", (event) => {
        state.bubbleBucket = event.target.value;
        renderBubble();
      });
      el.bubbleYear.addEventListener("input", (event) => {
        state.bubbleYear = Number(event.target.value);
        renderBubble();
      });

      el.playYears.addEventListener("click", () => {
        if (state.timer) {
          clearInterval(state.timer);
          state.timer = null;
          el.playYears.textContent = "Play Timeline";
          return;
        }
        el.playYears.textContent = "Stop";
        state.timer = setInterval(() => {
          state.bubbleYear = state.bubbleYear >= 2023 ? 2003 : state.bubbleYear + 1;
          el.bubbleYear.value = String(state.bubbleYear);
          renderBubble();
        }, 750);
      });

      el.heatScheme.addEventListener("change", (event) => {
        state.heatScheme = event.target.value;
        renderHeatmap();
      });
      el.heatBucket.addEventListener("change", (event) => {
        state.heatBucket = event.target.value;
        renderHeatmap();
      });
      el.heatLetter.addEventListener("change", (event) => {
        state.heatLetter = event.target.value;
        renderHeatmap();
      });

      el.flowMin.addEventListener("input", (event) => {
        state.flowMin = Number(event.target.value);
        renderFlow();
        renderFlowTable();
      });

      el.flowMax.addEventListener("input", (event) => {
        state.flowMax = Number(event.target.value);
        renderFlow();
        renderFlowTable();
      });

      el.claimStatus.addEventListener("change", (event) => {
        state.claimStatus = event.target.value;
        renderClaims();
      });
      el.claimSearch.addEventListener("input", (event) => {
        state.claimSearch = event.target.value.trim().toLowerCase();
        renderClaims();
      });
    }

    function renderTrend() {
      const rows = state.data.series.yearly.filter(
        (row) => row.scheme === state.trendScheme && row.bucket === state.trendBucket && state.selectedLetters.has(row.letter)
      );

      const grouped = new Map();
      rows.forEach((row) => {
        const current = grouped.get(row.letter) || [];
        current.push(row);
        grouped.set(row.letter, current);
      });

      const traces = Array.from(grouped.keys())
        .sort(byCategoryOrder)
        .map((letter, index) => {
          const points = grouped.get(letter).sort((a, b) => a.year - b.year);
          return {
            type: "scatter",
            mode: "lines",
            stackgroup: "one",
            line: { width: 1.8, color: CATEGORY_COLOR[letter] || "#88ccff" },
            fill: index === 0 ? "tozeroy" : "tonexty",
            name: categoryName(letter),
            x: points.map((p) => p.year),
            y: points.map((p) => p.weight),
            hovertemplate: "%{x}<br>%{y:,.0f} weighted deaths<extra>" + categoryName(letter) + "</extra>",
          };
        });

      Plotly.newPlot(
        "trend-plot",
        traces,
        {
          margin: { t: 25, r: 8, b: 44, l: 66 },
          paper_bgcolor: "rgba(0,0,0,0)",
          plot_bgcolor: "rgba(0,0,0,0)",
          xaxis: { title: "Year", gridcolor: "rgba(170,205,235,0.15)" },
          yaxis: { title: "Weighted deaths", gridcolor: "rgba(170,205,235,0.15)" },
          legend: { orientation: "h", y: -0.3, font: { color: "#d9efff" } },
          title: { text: `${schemeName(state.trendScheme)} | ${state.trendBucket}`, font: { color: "#e9f7ff", size: 16 } },
        },
        { responsive: true, displaylogo: false }
      );
    }

    function renderBubble() {
      const rows = state.data.series.yearly.filter(
        (row) => row.scheme === state.bubbleScheme && row.bucket === state.bubbleBucket && row.year === state.bubbleYear
      );

      const total = rows.reduce((sum, row) => sum + row.weight, 0);
      const change = state.data.claim_metrics.category_change_pct;

      const x = [];
      const y = [];
      const markerSize = [];
      const colors = [];
      const labels = [];
      rows
        .slice()
        .sort((a, b) => byCategoryOrder(a.letter, b.letter))
        .forEach((row) => {
          const share = total > 0 ? (row.weight / total) * 100 : 0;
          x.push(change[row.letter] || 0);
          y.push(share);
          markerSize.push(Math.max(9, Math.sqrt(row.weight) / 7));
          colors.push(CATEGORY_COLOR[row.letter] || "#8fd3ff");
          labels.push(`${categoryName(row.letter)}<br>${fmtInt(row.weight)} deaths`);
        });

      el.yearBadge.textContent = `Selected Year: ${state.bubbleYear}`;

      Plotly.newPlot(
        "bubble-plot",
        [
          {
            type: "scatter",
            mode: "markers+text",
            x,
            y,
            text: labels.map((label) => label.split("<br>")[0]),
            textposition: "top center",
            hovertemplate: "%{text}<br>Share: %{y:.2f}%<br>Reclassification change: %{x:.2f}%<extra></extra>",
            marker: {
              size: markerSize,
              color: colors,
              opacity: 0.86,
              line: { color: "rgba(239,252,255,0.7)", width: 1.1 },
            },
          },
        ],
        {
          margin: { t: 20, r: 12, b: 46, l: 56 },
          paper_bgcolor: "rgba(0,0,0,0)",
          plot_bgcolor: "rgba(0,0,0,0)",
          xaxis: { title: "Entity -> Record change (%)", zeroline: true, zerolinecolor: "rgba(255,255,255,0.35)", gridcolor: "rgba(170,205,235,0.15)" },
          yaxis: { title: "Share of weighted deaths (%)", gridcolor: "rgba(170,205,235,0.15)" },
        },
        { responsive: true, displaylogo: false }
      );
    }

    function renderHeatmap() {
      const rows = state.data.series.monthly.filter(
        (row) => row.scheme === state.heatScheme && row.bucket === state.heatBucket && row.letter === state.heatLetter
      );

      const years = sortedUnique(rows.map((row) => String(row.year))).map(Number);
      const months = Array.from({ length: 12 }, (_, idx) => idx + 1);
      const map = new Map(rows.map((row) => [`${row.year}-${row.month}`, row.weight]));
      const z = years.map((year) => months.map((month) => map.get(`${year}-${month}`) || 0));

      Plotly.newPlot(
        "heat-plot",
        [
          {
            type: "heatmap",
            x: months,
            y: years,
            z,
            colorscale: [
              [0, "#0b2b40"],
              [0.3, "#1b6683"],
              [0.6, "#30a6a9"],
              [0.8, "#ffad69"],
              [1, "#ffe57f"],
            ],
            hovertemplate: "Year %{y}, Month %{x}<br>%{z:,.0f} weighted deaths<extra></extra>",
          },
        ],
        {
          margin: { t: 24, r: 10, b: 40, l: 54 },
          paper_bgcolor: "rgba(0,0,0,0)",
          plot_bgcolor: "rgba(0,0,0,0)",
          title: { text: `${categoryName(state.heatLetter)} | ${schemeName(state.heatScheme)} | ${state.heatBucket}`, font: { color: "#dff2ff", size: 14 } },
          xaxis: { title: "Month", dtick: 1 },
          yaxis: { title: "Year" },
        },
        { responsive: true, displaylogo: false }
      );
    }

    function currentFlowRows() {
      return state.data.claim_metrics.transitions
        .filter((row) => row.count >= state.flowMin)
        .sort((a, b) => b.count - a.count)
        .slice(0, state.flowMax);
    }

    function renderFlow() {
      const rows = currentFlowRows();
      const letters = sortedUnique(rows.flatMap((row) => [row.from, row.to])).sort(byCategoryOrder);
      const index = new Map(letters.map((letter, idx) => [letter, idx]));

      el.flowMinLabel.textContent = `Min flow: ${fmtInt(state.flowMin)}`;
      el.flowMaxLabel.textContent = `Edges shown: ${rows.length} (max ${state.flowMax})`;

      Plotly.newPlot(
        "flow-plot",
        [
          {
            type: "sankey",
            arrangement: "snap",
            node: {
              pad: 12,
              thickness: 16,
              line: { color: "rgba(224,247,255,0.45)", width: 0.8 },
              label: letters.map(categoryName),
              color: letters.map((letter) => CATEGORY_COLOR[letter] || "#88d8ff"),
            },
            link: {
              source: rows.map((row) => index.get(row.from)),
              target: rows.map((row) => index.get(row.to)),
              value: rows.map((row) => row.count),
              color: rows.map((row) => {
                const base = CATEGORY_COLOR[row.from] || "#89d4ff";
                return base + "99";
              }),
              hovertemplate: "%{source.label} -> %{target.label}<br>%{value:,.0f}<extra></extra>",
            },
          },
        ],
        {
          margin: { t: 20, r: 8, b: 12, l: 8 },
          paper_bgcolor: "rgba(0,0,0,0)",
        },
        { responsive: true, displaylogo: false }
      );
    }

    function renderImpact() {
      const change = state.data.claim_metrics.category_change_pct;
      const letters = Object.keys(change).sort(byCategoryOrder);

      Plotly.newPlot(
        "impact-plot",
        [
          {
            type: "bar",
            orientation: "h",
            y: letters.map(categoryName),
            x: letters.map((letter) => change[letter]),
            marker: {
              color: letters.map((letter) => (change[letter] >= 0 ? "#19d3b8" : "#ff9466")),
            },
            hovertemplate: "%{y}<br>%{x:.2f}%<extra></extra>",
          },
        ],
        {
          margin: { t: 16, r: 10, b: 38, l: 180 },
          paper_bgcolor: "rgba(0,0,0,0)",
          plot_bgcolor: "rgba(0,0,0,0)",
          xaxis: { title: "Change (%)", gridcolor: "rgba(170,205,235,0.15)", zerolinecolor: "rgba(255,255,255,0.35)" },
          yaxis: { automargin: true },
        },
        { responsive: true, displaylogo: false }
      );
    }

    function renderClaims() {
      let rows = state.data.claim_metrics.checks;

      if (state.claimStatus === "pass") {
        rows = rows.filter((row) => row.pass);
      } else if (state.claimStatus === "fail") {
        rows = rows.filter((row) => !row.pass);
      }

      if (state.claimSearch) {
        rows = rows.filter((row) => row.label.toLowerCase().includes(state.claimSearch));
      }

      el.claimBody.innerHTML = rows
        .map((row) => {
          const expected = Number.isInteger(row.expected) ? fmtInt(row.expected) : fmtNum(row.expected, 3);
          const observed = Number.isInteger(row.observed) ? fmtInt(row.observed) : fmtNum(row.observed, 3);
          const diff = row.difference === null ? "NA" : fmtNum(row.difference, 3);
          const tol = Number.isInteger(row.tolerance) ? fmtInt(row.tolerance) : fmtNum(row.tolerance, 3);
          const cls = row.pass ? "ok" : "no";
          const label = row.pass ? "PASS" : "FAIL";
          return `<tr>
            <td title="${row.label}">${row.label}</td>
            <td>${expected}</td>
            <td>${observed}</td>
            <td>${diff}</td>
            <td>${tol}</td>
            <td><span class="badge ${cls}">${label}</span></td>
          </tr>`;
        })
        .join("");
    }

    function renderFlowTable() {
      const rows = currentFlowRows();
      el.flowTable.innerHTML = rows
        .map(
          (row) =>
            `<tr><td>${categoryName(row.from)}</td><td>${categoryName(row.to)}</td><td>${fmtInt(row.count)}</td></tr>`
        )
        .join("");
    }

    async function fetchData() {
      const response = await fetch("assets/site_data.json", { cache: "no-cache" });
      if (!response.ok) {
        throw new Error(`Unable to fetch site data (${response.status})`);
      }
      return response.json();
    }

    async function boot() {
      try {
        state.data = await fetchData();
        buildHero();
        setupControls();
        renderTrend();
        renderBubble();
        renderHeatmap();
        renderFlow();
        renderImpact();
        renderClaims();
        renderFlowTable();

        el.loading.classList.add("hidden");
        el.app.classList.remove("hidden");
      } catch (error) {
        el.loading.innerHTML = "Failed to load interactive data. Check docs/assets/site_data.json.";
        console.error(error);
      }
    }

    boot();
  </script>
</body>
</html>
